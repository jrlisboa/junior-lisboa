---
title: "Flutter: Comece a animar suas listas"
date: "2023-05-23"
slug: "flutter-animated-lists"
lang: "pt"
type: "article"
category: "flutter"
hero_image: "./flutter-animated-lists.png"
---

Muitas vezes deixamos de adicionar anima√ß√µes em alguns componentes da interface por quest√£o de complexidade, justificando ser um esfor√ßo desnecess√°rio e com valor agregado baixo, mas n√£o √© bem assim.

Nossos olhos est√£o acostumados com movimentos org√¢nicos, e ver um item saindo do ponto A para o ponto B ou at√© mesmo sumindo da tela, sem qualquer transi√ß√£o indicando o que aconteceu, vai nos deixar realmente confusos.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hcwn52g74nuym39bkih5.gif)

Isso se agrava quando se trata de uma lista de objetos, j√° que ali temos muito mais informa√ß√µes com as quais nos preocupar, e quanto mais din√¢mico isso fica, pior √© a experi√™ncia na utiliza√ß√£o.

---

## O que s√£o Animated Lists

Como tudo no Flutter, √© mais um widget, mas n√£o qualquer widget. A AnimatedList faz parte do grupo de widgets que auxiliam na constru√ß√£o de comportamentos de transi√ß√£o no flutter, como por exemplo, o AnimatedContainer, AnimatedCrossFade, AnimatedOpacity, e muitos outros, que podemos abordar em um outro momento.

```dart
// just another widget
AnimatedList();
```

Um dos pontos que faz o Flutter ser t√£o poderoso na constru√ß√£o de verdadeiras experi√™ncias, √© justamente a disponibilidade dessas ferramentas de anima√ß√£o pug and play, que nos permitem criar transi√ß√µes de forma simplificada, ou customizar de maneira mais complexa se necess√°rio.

---

## Funcionamento principal

A **AnimatedList** tem um funcionamento parecido com a **ListView.builder**, que cria um scroll na tela estimando a quantidade de elementos que ser√£o necess√°rios durante o build.

Por√©m, a forma como o **AnimatedList** decide se vai fazer o build de um item ou n√£o √© um pouco diferente, por isso a propriedade que recebe o tamanho da lista se chama `initialItemCount`, e n√£o `itemCount` como na **ListView.builder**.

Essa propriedade vai permitir que a AnimatedList configure o que vamos chamar de "lista fantasma‚Äù, onde as posi√ß√µes dos itens v√£o servir como refer√™ncia para que a lista decida quais itens precisam de um novo build, e qual ser√° a anima√ß√£o.



### Vamos implementar um exemplo

Por enquanto, vamos renderizar apenas um card ao abrir a p√°gina, sem a possibilidade de alterar a lista ou animar de alguma forma:

```dart
class _MyHomePageState extends State<MyHomePage> {
  // Atrav√©s da key vamos poder manipular a lista fantasma
  final _listKey = GlobalKey<AnimatedListState>();

  // A lista real, que ser√° utilizada para construir os itens
  final _myList = <String>['title1', 'title2', 'title3'];

  // Fun√ß√µes para manipular as listas
  _addNewItem() {}
  _removeItem(int index) {}

  @override
  Widget build(BuildContext context) => Scaffold(
        body: SafeArea(
          // Sua animated list na √†rvore de widgets
          child: AnimatedList(

            // Key √∫nica para cada lista
            key: _listKey,

            // Tamanho da lista real
            initialItemCount: _myList.length,

            // Build dos itens
            itemBuilder: (context, index, animation) {

                // Nosso item, sem anima√ß√£o por enquanto
                return MyCard(
                  onTap: () => _removeItem(index),
                  title: _myList[index],
                );
            },
          ),
        ),
      );
}
```



### Itens da nossa lista

Agora vamos criar tamb√©m um widget que representar√° o nosso item, ser√° chamado de `MyCard`. Neste exemplo vai receber um t√≠tulo, uma cor e um callback de click: 

```dart
class MyCard extends StatelessWidget {
  final String title;
  final Color color;
  final VoidCallback? onTap;
  const MyCard({
    super.key,
    required this.title,
    this.onTap,
    this.color = Colors.purpleAccent,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 100,
        width: double.infinity,
        margin: const EdgeInsets.all(10),
        padding: const EdgeInsets.all(10),
        color: color,
        child: Center(
          child: Text(
            title,
            style: const TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        ),
      ),
    );
  }
}
```

Nosso resultado at√© agora √© uma lista simples, que poderia ter sido criada por uma ListView ou at√© mesmo por uma Column. Mas a partir dela come√ßa a ficar mais interessante.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/bu2s9y5z5htqnz48a1e9.png)


---
## Criando uma anima√ß√£o

No momento em que a **AnimatedList** faz o build de um item, √© chamada uma fun√ß√£o (itemBuilder) que recebe as seguintes propriedades:

- `context` (BuildContext)
- `index` (int)
- `animation` ("Animation\<double\>"")

Com um `Animation<double>` dispon√≠vel, podemos adicionar um widget de Transition dentro do build, que ser√° um widget pai do item que estamos pretendendo renderizar.

O Flutter disponibiliza diversos widgets com essa premissa, como: [SizeTransition](https://api.flutter.dev/flutter/widgets/SizeTransition-class.html), [ScaleTransition](https://api.flutter.dev/flutter/widgets/ScaleTransition-class.html) ou [FadeTransition](https://api.flutter.dev/flutter/widgets/FadeTransition-class.html) por exemplo.

> Todos possuem a propriedade `child`, para receber o widget que ser√° afetado visualmente sempre que a propriedade de anima√ß√£o mudar.
> 

Vamos utilizar um SizeTransition por enquanto:

```dart
...
child: AnimatedList(
  key: _listKey,
  initialItemCount: _myList.length,
  itemBuilder: (context, index, animation) {

    // A AnimatedList controla a transi√ß√£o do item
    // - Para adicionar: ela amplia o animation em ordem crescente
    // - Para remover: ela reduz de forma decrescente

    return SizeTransition(
      sizeFactor: animation,
      child: MyCard(
        title: _myList[index],
      ),
    );
  },
),
...
```

---

## Adicionando e removendo itens

Uma coisa importante para se lembrar, √© que sempre que novos itens forem inseridos ou removidos da lista real vamos precisar avisar a **AnimatedList**, para que ela possa manipular sua lista fantasma no `index` correto, isso √© feito atrav√©s do `_listKey.currentState`.

Podemos criar ent√£o um bot√£o, que vai fazer o papel de incluir novos itens na nossa lista, e tamb√©m avisar o **currentState**.

```dart
@override
  Widget build(BuildContext context) => Scaffold(
        body: SafeArea(

          // Adicionando uma coluna
          child: Column(
            children: [
              const SizedBox(height: 50),

              // Nosso card tamb√©m ser√° o bot√£o
              MyCard(
                title: 'Add new item',
                color: Colors.orange,
                onTap: _addNewItem,
              ),

              // Sempre expanda listas dentro de Columns
              Expanded(
                child: AnimatedList(
                  ...
                ),
              ),
            ],
          ),
        ),
      );
```

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ezx7ij6zxyul7n68jf4v.png)



### Adicionar

Agora √© simples, para fazer o funcionamento deste bot√£o, s√≥ precisamos utilizar a nossa fun√ß√£o `_addNewItem` e inserir algo em ambas as listas (a real, e a fantasma).

Para inserir itens na lista fantasma, utilizamos o m√©todo `.insertItem()`, e nessa lista voc√™ deve sempre inserir um item por vez.

```dart
_addNewItem() {
  final index = _myList.length;
  final intem = 'title${index + 1}';

  _listKey.currentState?.insertItem(index);
  _myList.insert(index, intem);
}
```



### Remover

Para remover um item vamos utilizar a fun√ß√£o `.removeItem()`, e nela existe uma pequena diferen√ßa: al√©m do index do item que ser√° removido, vamos passar tamb√©m um builder, exatamente como o que passamos para a AnimatedList atrav√©s da propriedade `itemBuilder`.

<aside>
üí° **Importante**: Mantenha o conte√∫do em uma vari√°vel separada antes de manipular as listas, pois isso evita que card n√£o consiga exibir o conte√∫do correto durante toda a anima√ß√£o.

</aside>

```dart
_removeItem(int index) {
  final title = _myList[index];

  _listKey.currentState?.removeItem(
    index,
    (context, animation) => SizeTransition(
      sizeFactor: animation,
      child: MyCard(
        title: title,
      ),
    ),
  );
  _myList.removeAt(index);
}
```


---
## Resultado

Depois disso, o c√©u √© o limite, existem milhares de formas de explorar esse comportamento nos seus projetos, utilizando diversas transi√ß√µes (inclusive ao mesmo tempo) e alterando comportamentos como **curva** e **dura√ß√£o**.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xwnl6mx5otyl7mjsz9ay.gif)

---

## Animando o primeiro build

Pra finalizar, utilizando os m√©todos que criamos aqui, para exibir uma anima√ß√£o inicial nos itens voc√™ s√≥ precisa fazer 2 coisas:

- Dizer para a AnimatedList iniciar sem nenhum item na lista fantasma, apenas colocando **0** na propriedade `initialItemCount`.
- Adicionar os itens ap√≥s a renderiza√ß√£o da p√°gina, isso pode ser feito chamando o `addPostFrameCallback` dentro do seu `initState`.

```dart
@override
void initState() {
  super.initState();
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    for (var i = 0; i < _myList.length; i++) {
      _listKey.currentState?.insertItem(i);
      await Future.delayed(const Duration(milliseconds: 500));
    }
  });
}

...
AnimatedList(
	initialItemCount: 0,
	...
)
```

Desta forma, essa ser√° nossa tela ap√≥s o primeiro build:

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4g64v038ebc928jlxwyy.gif)

---

## üíõ Muito obrigado

Me avise se encontrar algo que eu precise corrigir ou melhorar. Espero que eu tenha contribu√≠do com esse texto de alguma forma, sinta-se livre para deixar um coment√°rio ou sugest√£o. 

Me acompanhe no Twitter (@juniorlisboa29), estou come√ßando a falar de tecnologia por l√° tamb√©m. Um abra√ßo, e at√© a pr√≥xima! üöÄ
